---
title: CLR via 第4章 类型基础
date: 2021-06-25 13:15:46
tags: C# 
---

> by the way 此文章主要用来记录我阅读过程中记下应该写下来,或者说应该要牢记的知识点

---

# 第4章: 类型基础

1. 所有类型都是从 `System.Object` 派生

新建一个类型,就算不写继承于谁,默认都是继承了 `Object`
`Object` 类中包含了 `Equals` `GetHashCode` `ToString` `GetType` 等几个方法,所以你才能在一般的类中使用这些方法.

2. 类型转换

> CLR最重要的特性之一就是类型安全, 在运行时,clr总能知道这个对象的类型是什么,调用 GetType 方法就知道,而且GetType不是虚方法,所以一个类型不可能伪装成为另一个类型

> c#不要求任何特殊语法即可将对象转换为它的任意基类型,因为向基转换被认为是一种安全的隐式转换, 但是相反的,由基类型转向派生类型时c#要求开发人员要进行显示转换,因为这种转换有可能会失败

3. 使用`is` 和 `as` 来转换类型

可以使用 `is` 来进行类型转换,注意: `is` 操作符永远不会抛出异常 只会返回`true` 和 `false`

如果对象引用是 `null` ,这样总是会返回`false`,因为没有可以检查类型的对象

```c#
if(o is Employee){
    Employee e = (Employee) o;
}
```

可以看出以上的代码检查了两次o的类型,对性能很不好,所以c#专门提供了as操作符,目的就是简化这种代码

`as`可以核实是否兼容`Employee`类型,同时会返回一个`Employee`的非`null`引用.当然如果o不能转型,结果就会是`null`;

4. clr调用一个方法的过程,详见书本108页,由于没有图床,所以没有解析了
所以就直接讲下我的理解

```c#
void M1(){
    string name = "Joe";
    M2(name);
    ...
    return;
}
void M2(string s){
    int length = s.Length;
    int tally;
    ...
    return;
}
```

- 首先执行m1方法,读到name变量 会把name压栈
- 然后执行M2,这时候会创建一个m2的局部变量块,把s压栈
- 然后把m2的return压栈,使得被调用的方法结束后可以返回值该位置
- 然后m2方法也会为length和tally在栈中创建位置,最后调用完回到上面的返回位置

如果使用了引用类型比如说自定义的一个class,这时候就不仅在栈开辟空间了,还会在托管堆里面开辟空间

假设有两个复杂类型 `Manager` 和 `Employee`,
首先clr会为方法中的所有局部变量都初始化为`null`或者`0`,如果代码企图访问未显式初始化的局部变量,c#就会报告空引用异常,

像 `Manager` 这种复杂类型,会在托管堆中创建一个实例,里面会有几个东西

1. 类型对象指针
2. 同步块索引
3. 静态字段
4. 自定义的字段
5. 方法表

>类型对象指针：指向类型对象存储的地址，假如有一个类型Person,它在堆中有一块区域存储它内部的字段和成员以及两个额外成员（类型对象指针、 同步块索引 ），类型对象的类型对象指针指向的是System.Type的地址。
因为Person类型在内存中相对于System.Type也是作为一个对象存在的，System.Type类型也是一个类型对象，它的类型对象指针指向本身；
实例化一个Person对象，Person p = new Person(); p对象在内存堆中也分配一块区域存储它内部的字段和成员以及两个额外成员（类型对象指针、 同步块索引 ），p的类型对象指针指向Person类型在堆中的地址。
同步块索引：先说一下同步块，.NET团队在设计基本框架时充分考虑了线程同步的问题，其结果就是.NET为每一个堆内对象都提供了支持线程同步的功能，这就是同步机制的雏形【参考：<http://genwoxuedotnet.blog.51cto.com/1852748/504107>】
但是对每个堆内对象都分配同步块有一个较大的弊端，就是这样增大了内存的消耗。在一般的系统中，需要同步机制支持的对象可能只占少数，这样对于大多数对象来说，一个同步块的内存消耗就完全被浪费了。鉴于这一点，.NET框架采用了一种折中的办法，就是实际只为每个堆内对象分配一个同步索引，该索引中只保存一个表明数组内索引的整数。.NET在加载时会新建一个同步块数组，当某个对象需要被同步时，.NET会为其分配一个同步块，并且把该同步块在同步块数组中的索引加入该对象的同步块索引中。
同步块机制包含如下的几点：
· 在.NET被加载时初始化同步块数组。
· 每一个被分配在堆上的对象都会包含两个额外的字段，其中一个存储类型指针，而另外一个就是同步块索引，初始时被赋值为-1。
· 当一个线程试图使用该对象进入同步时，会检查该对象的同步索引。如果索引为负数，则会在同步块数组中寻找或者新建一个同步块，并且把同步块的索引值写入该对象的同步索引中。如果该对象的同步索引不为负值，则找到该对象的同步块并且检查是否有其他线程在使用该同步块，如果有则进入等待状态，如果没有则申明使用该同步块。
以上引用来源于 <https://www.cnblogs.com/dawenyang/p/7520263.html>

clr调用一个非虚的实例方法的是否, jit会找到与"发出调用的那个变量(e)的类型(Employee)"对应的类型对象.但是如果Employee没找到,那么jit就会回溯层次结构,一直回溯到Object,并在沿途的每个类型中查找该方法.之所以能这样回溯,是**因为每个类型对象都有个字段引用了它的基类型**
